import simpleGit, { SimpleGit, StatusResult } from 'simple-git';
import { nanoid } from 'nanoid';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { Checkpoint, FileChange, Message, ICheckpointTree } from '../types';

const CLAUDE_AGENT_DIR = '.claude-agent';
const CHECKPOINTS_FILE = 'checkpoints.json';
const BRANCH_PREFIX = 'claude-agent/';

export interface GitCheckpointStorageOptions {
  workingDir: string;
  sessionId?: string;
}

/**
 * GitCheckpointStorage - Handles git operations for checkpoint persistence
 */
export class GitCheckpointStorage {
  private git: SimpleGit;
  private workingDir: string;
  private sessionId: string;
  private branchName: string;
  private initialized = false;

  constructor(options: GitCheckpointStorageOptions) {
    this.workingDir = options.workingDir;
    this.sessionId = options.sessionId || nanoid(8);
    this.branchName = `${BRANCH_PREFIX}${this.sessionId}`;
    this.git = simpleGit(this.workingDir);
  }

  get session(): string {
    return this.sessionId;
  }

  get branch(): string {
    return this.branchName;
  }

  /**
   * Initialize git storage for checkpoints
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    // Check if it's a git repo
    const isRepo = await this.git.checkIsRepo();
    if (!isRepo) {
      await this.git.init();
    }

    // Create .claude-agent directory
    const agentDir = path.join(this.workingDir, CLAUDE_AGENT_DIR);
    await fs.mkdir(agentDir, { recursive: true });

    // Add .claude-agent to .gitignore if not already there
    await this.ensureGitignore();

    // Create or checkout our working branch
    const branches = await this.git.branchLocal();
    if (!branches.all.includes(this.branchName)) {
      // Create a new branch from current HEAD
      const currentBranch = branches.current;
      await this.git.checkoutLocalBranch(this.branchName);
      // Go back to original branch for the working tree
      await this.git.checkout(currentBranch);
    }

    this.initialized = true;
  }

  /**
   * Ensure .claude-agent is in .gitignore
   */
  private async ensureGitignore(): Promise<void> {
    const gitignorePath = path.join(this.workingDir, '.gitignore');

    try {
      let content = await fs.readFile(gitignorePath, 'utf-8');
      if (!content.includes(CLAUDE_AGENT_DIR)) {
        content += `\n# Claude Agent\n${CLAUDE_AGENT_DIR}/\n`;
        await fs.writeFile(gitignorePath, content);
      }
    } catch {
      // Create new .gitignore
      await fs.writeFile(gitignorePath, `# Claude Agent\n${CLAUDE_AGENT_DIR}/\n`);
    }
  }

  /**
   * Create a checkpoint (git commit)
   */
  async createCheckpoint(
    title: string,
    description: string,
    messages: Message[],
    parentId: string | null
  ): Promise<Checkpoint> {
    await this.initialize();

    // Get current changes
    const status = await this.git.status();
    const filesChanged = this.statusToFileChanges(status);

    // Stage all changes
    if (filesChanged.length > 0) {
      await this.git.add('.');
    }

    // Create checkpoint metadata
    const checkpoint: Checkpoint = {
      id: nanoid(),
      parentId,
      childIds: [],
      timestamp: Date.now(),
      title,
      description,
      filesChanged,
      conversationSnapshot: messages,
      metadata: {
        branch: this.branchName,
        commitSha: '', // Will be set after commit
        isActive: true,
        autoGenerated: !title,
      },
    };

    // Commit with metadata in message
    const commitMessage = this.formatCommitMessage(checkpoint);

    try {
      const result = await this.git.commit(commitMessage, { '--allow-empty': null });
      checkpoint.metadata.commitSha = result.commit || '';
    } catch (err) {
      // If nothing to commit, create empty commit for checkpoint
      const result = await this.git.commit(commitMessage, { '--allow-empty': null });
      checkpoint.metadata.commitSha = result.commit || '';
    }

    // Save checkpoint tree
    await this.saveCheckpointMetadata(checkpoint);

    return checkpoint;
  }

  /**
   * Restore to a checkpoint
   */
  async restoreCheckpoint(checkpoint: Checkpoint): Promise<void> {
    await this.initialize();

    if (!checkpoint.metadata.commitSha) {
      throw new Error('Checkpoint has no commit SHA');
    }

    // Stash current changes if any
    const status = await this.git.status();
    const hasChanges = !status.isClean();

    if (hasChanges) {
      await this.git.stash(['push', '-m', `Before restore to ${checkpoint.id}`]);
    }

    // Checkout the commit
    await this.git.checkout(checkpoint.metadata.commitSha);

    // Update checkpoint metadata
    await this.updateCheckpointActive(checkpoint.id);
  }

  /**
   * Get diff between two checkpoints
   */
  async getDiff(fromId: string, toId: string): Promise<string> {
    const from = await this.getCheckpointCommit(fromId);
    const to = await this.getCheckpointCommit(toId);

    if (!from || !to) {
      throw new Error('Checkpoint not found');
    }

    return this.git.diff([from, to]);
  }

  /**
   * Get diff for a single checkpoint (changes from parent)
   */
  async getCheckpointDiff(checkpointId: string): Promise<string> {
    const metadata = await this.loadCheckpointMetadata();
    const checkpoint = metadata.nodes[checkpointId];

    if (!checkpoint) {
      throw new Error('Checkpoint not found');
    }

    const commitSha = checkpoint.metadata.commitSha;
    if (!commitSha) {
      return '';
    }

    // Diff against parent or show initial commit diff
    if (checkpoint.parentId) {
      const parent = metadata.nodes[checkpoint.parentId];
      if (parent?.metadata.commitSha) {
        return this.git.diff([parent.metadata.commitSha, commitSha]);
      }
    }

    // Show diff of the commit itself
    return this.git.show([commitSha, '--format=']);
  }

  /**
   * List all stashes (for recovery)
   */
  async listStashes(): Promise<Array<{ index: number; message: string }>> {
    const result = await this.git.stashList();
    return result.all.map((entry, index) => ({
      index,
      message: entry.message,
    }));
  }

  /**
   * Pop a stash
   */
  async popStash(index?: number): Promise<void> {
    if (index !== undefined) {
      await this.git.stash(['pop', `stash@{${index}}`]);
    } else {
      await this.git.stash(['pop']);
    }
  }

  /**
   * Convert git status to FileChange array
   */
  private statusToFileChanges(status: StatusResult): FileChange[] {
    const changes: FileChange[] = [];

    for (const file of status.created) {
      changes.push({
        path: file,
        type: 'added',
        additions: 0,
        deletions: 0,
      });
    }

    for (const file of status.modified) {
      changes.push({
        path: file,
        type: 'modified',
        additions: 0,
        deletions: 0,
      });
    }

    for (const file of status.deleted) {
      changes.push({
        path: file,
        type: 'deleted',
        additions: 0,
        deletions: 0,
      });
    }

    for (const file of status.renamed) {
      changes.push({
        path: file.to,
        oldPath: file.from,
        type: 'renamed',
        additions: 0,
        deletions: 0,
      });
    }

    return changes;
  }

  /**
   * Format commit message with checkpoint metadata
   */
  private formatCommitMessage(checkpoint: Checkpoint): string {
    const meta = {
      checkpointId: checkpoint.id,
      parentId: checkpoint.parentId,
      timestamp: checkpoint.timestamp,
    };

    return `${checkpoint.title || 'Checkpoint'}\n\n${checkpoint.description || ''}\n\n---\nCLAUDE_AGENT_META:${JSON.stringify(meta)}`;
  }

  /**
   * Save checkpoint metadata to file
   */
  private async saveCheckpointMetadata(checkpoint: Checkpoint): Promise<void> {
    const filePath = path.join(this.workingDir, CLAUDE_AGENT_DIR, CHECKPOINTS_FILE);
    let tree: ICheckpointTree;

    try {
      const content = await fs.readFile(filePath, 'utf-8');
      tree = JSON.parse(content);
    } catch {
      tree = {
        root: null,
        nodes: {},
        currentId: null,
        activeLineage: [],
      };
    }

    // Add checkpoint
    tree.nodes[checkpoint.id] = checkpoint;

    // Update parent's children
    if (checkpoint.parentId && tree.nodes[checkpoint.parentId]) {
      const parent = tree.nodes[checkpoint.parentId];
      if (!parent.childIds.includes(checkpoint.id)) {
        parent.childIds.push(checkpoint.id);
      }
      parent.metadata.isActive = false;
    }

    // Update root if needed
    if (!tree.root) {
      tree.root = checkpoint.id;
    }

    // Update current
    tree.currentId = checkpoint.id;

    // Update lineage
    tree.activeLineage = this.computeLineage(tree, checkpoint.id);

    await fs.writeFile(filePath, JSON.stringify(tree, null, 2));
  }

  /**
   * Load checkpoint metadata from file
   */
  async loadCheckpointMetadata(): Promise<ICheckpointTree> {
    const filePath = path.join(this.workingDir, CLAUDE_AGENT_DIR, CHECKPOINTS_FILE);

    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return {
        root: null,
        nodes: {},
        currentId: null,
        activeLineage: [],
      };
    }
  }

  /**
   * Update which checkpoint is active
   */
  private async updateCheckpointActive(activeId: string): Promise<void> {
    const filePath = path.join(this.workingDir, CLAUDE_AGENT_DIR, CHECKPOINTS_FILE);
    const tree = await this.loadCheckpointMetadata();

    // Mark all as inactive
    for (const id in tree.nodes) {
      tree.nodes[id].metadata.isActive = false;
    }

    // Mark active
    if (tree.nodes[activeId]) {
      tree.nodes[activeId].metadata.isActive = true;
    }

    tree.currentId = activeId;
    tree.activeLineage = this.computeLineage(tree, activeId);

    await fs.writeFile(filePath, JSON.stringify(tree, null, 2));
  }

  /**
   * Compute lineage from root to given checkpoint
   */
  private computeLineage(tree: ICheckpointTree, checkpointId: string): string[] {
    const lineage: string[] = [];
    let current: Checkpoint | undefined = tree.nodes[checkpointId];

    while (current) {
      lineage.unshift(current.id);
      current = current.parentId ? tree.nodes[current.parentId] : undefined;
    }

    return lineage;
  }

  /**
   * Get commit SHA for a checkpoint
   */
  private async getCheckpointCommit(checkpointId: string): Promise<string | null> {
    const tree = await this.loadCheckpointMetadata();
    return tree.nodes[checkpointId]?.metadata.commitSha || null;
  }
}
